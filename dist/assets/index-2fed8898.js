(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))r(n);new MutationObserver(n=>{for(const s of n)if(s.type==="childList")for(const a of s.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&r(a)}).observe(document,{childList:!0,subtree:!0});function t(n){const s={};return n.integrity&&(s.integrity=n.integrity),n.referrerPolicy&&(s.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?s.credentials="include":n.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function r(n){if(n.ep)return;n.ep=!0;const s=t(n);fetch(n.href,s)}})();class h{constructor(e){this.compare=e||h.defaultCompareFunction}static defaultCompareFunction(e,t){return e===t?0:e<t?-1:1}equal(e,t){return this.compare(e,t)===0}lessThan(e,t){return this.compare(e,t)<0}greaterThan(e,t){return this.compare(e,t)>0}lessThanOrEqual(e,t){return this.lessThan(e,t)||this.equal(e,t)}greaterThanOrEqual(e,t){return this.greaterThan(e,t)||this.equal(e,t)}reverse(){const e=this.compare;this.compare=(t,r)=>e(r,t)}}class c{constructor(e){if(new.target===c)throw new TypeError("Cannot construct Heap instance directly");this.heapContainer=[],this.compare=new h(e)}getLeftChildIndex(e){return 2*e+1}getRightChildIndex(e){return 2*e+2}getParentIndex(e){return Math.floor((e-1)/2)}hasParent(e){return this.getParentIndex(e)>=0}hasLeftChild(e){return this.getLeftChildIndex(e)<this.heapContainer.length}hasRightChild(e){return this.getRightChildIndex(e)<this.heapContainer.length}leftChild(e){return this.heapContainer[this.getLeftChildIndex(e)]}rightChild(e){return this.heapContainer[this.getRightChildIndex(e)]}parent(e){return this.heapContainer[this.getParentIndex(e)]}swap(e,t){const r=this.heapContainer[t];this.heapContainer[t]=this.heapContainer[e],this.heapContainer[e]=r}peek(){return this.heapContainer.length===0?null:this.heapContainer[0]}poll(){if(this.heapContainer.length===0)return null;if(this.heapContainer.length===1)return this.heapContainer.pop();const e=this.heapContainer[0];return this.heapContainer[0]=this.heapContainer.pop(),this.heapifyDown(),e}add(e){return this.heapContainer.push(e),this.heapifyUp(),this}remove(e,t=this.compare){const r=this.find(e,t).length;for(let n=0;n<r;n+=1){const s=this.find(e,t).pop();if(s===this.heapContainer.length-1)this.heapContainer.pop();else{this.heapContainer[s]=this.heapContainer.pop();const a=this.parent(s);this.hasLeftChild(s)&&(!a||this.pairIsInCorrectOrder(a,this.heapContainer[s]))?this.heapifyDown(s):this.heapifyUp(s)}}return this}find(e,t=this.compare){const r=[];for(let n=0;n<this.heapContainer.length;n+=1)t.equal(e,this.heapContainer[n])&&r.push(n);return r}isEmpty(){return!this.heapContainer.length}toString(){return this.heapContainer.toString()}heapifyUp(e){let t=e||this.heapContainer.length-1;for(;this.hasParent(t)&&!this.pairIsInCorrectOrder(this.parent(t),this.heapContainer[t]);)this.swap(t,this.getParentIndex(t)),t=this.getParentIndex(t)}heapifyDown(e=0){let t=e,r=null;for(;this.hasLeftChild(t)&&(this.hasRightChild(t)&&this.pairIsInCorrectOrder(this.rightChild(t),this.leftChild(t))?r=this.getRightChildIndex(t):r=this.getLeftChildIndex(t),!this.pairIsInCorrectOrder(this.heapContainer[t],this.heapContainer[r]));)this.swap(t,r),t=r}pairIsInCorrectOrder(e,t){throw new Error(`
      You have to implement heap pair comparision method
      for ${e} and ${t} values.
    `)}}class E extends c{pairIsInCorrectOrder(e,t){return this.compare.lessThanOrEqual(e,t)}}class v extends E{constructor(){super(),this.priorities=new Map,this.compare=new h(this.comparePriority.bind(this))}add(e,t=0){return this.priorities.set(e,t),super.add(e),this}remove(e,t){return super.remove(e,t),this.priorities.delete(e),this}changePriority(e,t){return this.remove(e,new h(this.compareValue)),this.add(e,t),this}findByValue(e){return this.find(e,new h(this.compareValue))}hasValue(e){return this.findByValue(e).length>0}comparePriority(e,t){return this.priorities.get(e)===this.priorities.get(t)?0:this.priorities.get(e)<this.priorities.get(t)?-1:1}compareValue(e,t){return e===t?0:e<t?-1:1}}function C(i,e){const t={},r={},n={},s=new v;for(i.getAllVertices().forEach(a=>{t[a.getKey()]=1/0,n[a.getKey()]=null}),t[e.getKey()]=0,s.add(e,t[e.getKey()]);!s.isEmpty();){const a=s.poll();a.getNeighbors().forEach(o=>{if(!r[o.getKey()]){const m=i.findEdge(a,o),x=t[o.getKey()],g=t[a.getKey()]+m.weight;g<x&&(t[o.getKey()]=g,s.hasValue(o)&&s.changePriority(o,t[o.getKey()]),n[o.getKey()]=a),s.hasValue(o)||s.add(o,t[o.getKey()])}}),r[a.getKey()]=a}return{distances:t,previousVertices:n}}class I{constructor(e=!1){this.vertices={},this.edges={},this.isDirected=e}addVertex(e){return this.vertices[e.getKey()]=e,this}getVertexByKey(e){return this.vertices[e]}getNeighbors(e){return e.getNeighbors()}getAllVertices(){return Object.values(this.vertices)}getAllEdges(){return Object.values(this.edges)}addEdge(e){let t=this.getVertexByKey(e.startVertex.getKey()),r=this.getVertexByKey(e.endVertex.getKey());if(t||(this.addVertex(e.startVertex),t=this.getVertexByKey(e.startVertex.getKey())),r||(this.addVertex(e.endVertex),r=this.getVertexByKey(e.endVertex.getKey())),this.edges[e.getKey()])throw new Error("Edge has already been added before");return this.edges[e.getKey()]=e,this.isDirected?t.addEdge(e):(t.addEdge(e),r.addEdge(e)),this}deleteEdge(e){if(this.edges[e.getKey()])delete this.edges[e.getKey()];else throw new Error("Edge not found in graph");const t=this.getVertexByKey(e.startVertex.getKey()),r=this.getVertexByKey(e.endVertex.getKey());t.deleteEdge(e),r.deleteEdge(e)}findEdge(e,t){const r=this.getVertexByKey(e.getKey());return r?r.findEdge(t):null}getWeight(){return this.getAllEdges().reduce((e,t)=>e+t.weight,0)}reverse(){return this.getAllEdges().forEach(e=>{this.deleteEdge(e),e.reverse(),this.addEdge(e)}),this}getVerticesIndices(){const e={};return this.getAllVertices().forEach((t,r)=>{e[t.getKey()]=r}),e}getAdjacencyMatrix(){const e=this.getAllVertices(),t=this.getVerticesIndices(),r=Array(e.length).fill(null).map(()=>Array(e.length).fill(1/0));return e.forEach((n,s)=>{n.getNeighbors().forEach(a=>{const o=t[a.getKey()];r[s][o]=this.findEdge(n,a).weight})}),r}toString(){return Object.keys(this.vertices).toString()}}class y{constructor(e,t,r=0){this.startVertex=e,this.endVertex=t,this.weight=r}getKey(){const e=this.startVertex.getKey(),t=this.endVertex.getKey();return`${e}_${t}`}reverse(){const e=this.startVertex;return this.startVertex=this.endVertex,this.endVertex=e,this}toString(){return this.getKey()}}class u{constructor(e,t=null){this.value=e,this.next=t}toString(e){return e?e(this.value):`${this.value}`}}class V{constructor(e){this.head=null,this.tail=null,this.compare=new h(e)}prepend(e){const t=new u(e,this.head);return this.head=t,this.tail||(this.tail=t),this}append(e){const t=new u(e);return this.head?(this.tail.next=t,this.tail=t,this):(this.head=t,this.tail=t,this)}insert(e,t){const r=t<0?0:t;if(r===0)this.prepend(e);else{let n=1,s=this.head;const a=new u(e);for(;s&&n!==r;)s=s.next,n+=1;s?(a.next=s.next,s.next=a):this.tail?(this.tail.next=a,this.tail=a):(this.head=a,this.tail=a)}return this}delete(e){if(!this.head)return null;let t=null;for(;this.head&&this.compare.equal(this.head.value,e);)t=this.head,this.head=this.head.next;let r=this.head;if(r!==null)for(;r.next;)this.compare.equal(r.next.value,e)?(t=r.next,r.next=r.next.next):r=r.next;return this.compare.equal(this.tail.value,e)&&(this.tail=r),t}find({value:e=void 0,callback:t=void 0}){if(!this.head)return null;let r=this.head;for(;r;){if(t&&t(r.value)||e!==void 0&&this.compare.equal(r.value,e))return r;r=r.next}return null}deleteTail(){const e=this.tail;if(this.head===this.tail)return this.head=null,this.tail=null,e;let t=this.head;for(;t.next;)t.next.next?t=t.next:t.next=null;return this.tail=t,e}deleteHead(){if(!this.head)return null;const e=this.head;return this.head.next?this.head=this.head.next:(this.head=null,this.tail=null),e}fromArray(e){return e.forEach(t=>this.append(t)),this}toArray(){const e=[];let t=this.head;for(;t;)e.push(t),t=t.next;return e}toString(e){return this.toArray().map(t=>t.toString(e)).toString()}reverse(){let e=this.head,t=null,r=null;for(;e;)r=e.next,e.next=t,t=e,e=r;return this.tail=this.head,this.head=t,this}}class w{constructor(e){if(e===void 0)throw new Error("Graph vertex must have a value");const t=(r,n)=>r.getKey()===n.getKey()?0:r.getKey()<n.getKey()?-1:1;this.value=e,this.edges=new V(t)}addEdge(e){return this.edges.append(e),this}deleteEdge(e){this.edges.delete(e)}getNeighbors(){const e=this.edges.toArray(),t=r=>r.value.startVertex===this?r.value.endVertex:r.value.startVertex;return e.map(t)}getEdges(){return this.edges.toArray().map(e=>e.value)}getDegree(){return this.edges.toArray().length}hasEdge(e){return!!this.edges.find({callback:r=>r===e})}hasNeighbor(e){return!!this.edges.find({callback:r=>r.startVertex===e||r.endVertex===e})}findEdge(e){const t=n=>n.startVertex===e||n.endVertex===e,r=this.edges.find({callback:t});return r?r.value:null}getKey(){return this.value}deleteAllEdges(){return this.getEdges().forEach(e=>this.deleteEdge(e)),this}toString(e){return e?e(this.value):`${this.value}`}}function B(i){const e=document.createElement("table");e.id="playgroundTable";for(let t=0;t<i;t++){const r=document.createElement("tr");for(let n=0;n<i;n++){const s=document.createElement("td"),a=`${t}:${n}`,o=`${t+n} - ${t}:${n}`;d.addVertex(new w(`v_${a}`)),s.style.padding="20px",s.style.textAlign="center",s.style.borderRadius="50%",s.style.border="1px solid black",s.id=a,s.addEventListener("mouseover",()=>s.style.cursor="pointer"),s.textContent=o,r.appendChild(s)}e.appendChild(r)}return e}function b(i){let e=!1;if(l.barrierPoints.length===0)l.barrierPoints.push(i);else{if(l.barrierPoints.forEach(t=>{t.id===i.id&&(e=!0)}),e)return console.error("Trùng lặp vật cản"),!1;l.barrierPoints.push(i)}return!0}function P(i){if(i.match(/v_\d+:\d+/)===null)throw new Error("Chuỗi không đúng định dạng");const e=i.split("_"),[t,r]=e[1].split(":");return`v_${Number(t)+1}:${r}`}function K(i){if(i.match(/v_\d+:\d+/)===null)throw new Error("Chuỗi không đúng định dạng");const e=i.split("_"),[t,r]=e[1].split(":");return`v_${t}:${Number(r)+1}`}function N(i){const e=P(i);if(d.vertices[e]!==void 0){const t=d.getVertexByKey(i),r=d.getVertexByKey(e),n=new y(t,r,1);d.addEdge(n)}}function $(i){const e=K(i);if(d.vertices[e]!==void 0){const t=d.getVertexByKey(i),r=d.getVertexByKey(e),n=new y(t,r,1);d.addEdge(n)}}function k(i,e){const t=e.getVertexByKey(i);return C(e,t)}function f(i,e){if(i.previousVertices[e]===null)return null;{const t=e.split("_")[1],r=document.getElementById(t);return r.style.backgroundColor="red",f(i,i.previousVertices[e].value)}}const L=document.getElementById("root");let p=!1;const l={n:null,startingPoint:null,endingPoint:null,barrierPoints:[]},A=document.getElementById("playgroundInitBtn");A.addEventListener("click",()=>{const i=document.getElementById("playgroundInitInput"),e=document.getElementById("playgroundData");if(i===null)throw new Error("Nhập vào null");if(p)throw new Error("Playground đã được khởi tạo");const t=Number(i.value),r=B(t);l.n=t,L.appendChild(r),p=!0,e.textContent=`Khởi tạo với n = ${i.value}`});const O=document.getElementById("startingPointInitBtn");O.addEventListener("click",()=>{const i=document.getElementById("xStartingPoint"),e=document.getElementById("yStartingPoint"),t=document.getElementById(`${i.value}:${e.value}`);t.style.backgroundColor="green",l.startingPoint={id:t.id,x:Number(i.value),y:Number(e.value),sum:Number(i.value)+Number(e.value)};const r=document.getElementById("startingPointData"),n=document.createElement("span");n.textContent=`${l.startingPoint.id}`,n.style.border="1px solid black",n.style.padding="5px",n.style.borderRadius="3px",n.style.display="inline-block",n.style.backgroundColor="green",r.appendChild(n)});const D=document.getElementById("endingPointInitBtn");D.addEventListener("click",()=>{const i=document.getElementById("xEndingPoint"),e=document.getElementById("yEndingPoint"),t=document.getElementById(`${i.value}:${e.value}`);t.style.backgroundColor="blue",l.endingPoint={id:t.id,x:Number(i.value),y:Number(e.value),sum:Number(i.value)+Number(e.value)};const r=document.getElementById("endingPointData"),n=document.createElement("span");n.textContent=`${l.endingPoint.id}`,n.style.padding="5px",n.style.border="1px solid black",n.style.borderRadius="3px",n.style.margin="5px",n.style.display="inline-block",n.style.backgroundColor="blue",r.appendChild(n)});const S=document.getElementById("addBarrierBtn");S.addEventListener("click",()=>{const i=document.getElementById("xBarrierPoint"),e=document.getElementById("yBarrierPoint"),t=document.getElementById(`${i.value}:${e.value}`);t.style.backgroundColor="DarkGray",t.className="barrier";const r={id:`${i.value}:${e.value}`,x:Number(i.value),y:Number(e.value),sum:Number(i.value)+Number(e.value)},n=b(r);if(delete d.vertices[`v_${r.id}`],n){const s=document.getElementById("barrierData"),a=document.createElement("span");a.textContent=r.id,a.style.border="1px solid black",a.style.margin="5px",a.style.padding="5px",a.style.borderRadius="3px",a.style.backgroundColor="DarkGray",s.appendChild(a)}});const d=new I,T=document.getElementById("createGraphBtn");T.addEventListener("click",()=>{var e,t;for(const r in d.vertices)$(r),N(r);const i=k(`v_${(e=l.startingPoint)==null?void 0:e.id}`,d);console.log(i),f(i,`v_${(t=l.endingPoint)==null?void 0:t.id}`)});
